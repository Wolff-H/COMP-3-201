import random


"""
    return an associated array
        i_and_fitness = [i,fitness]
"""
def toAssocArray(arr) :
    array = arr.copy()

    i_and_fitness = []

    for i in range( len(array) ):
        i_and_fitness.append( [i,array[i]] )

    return i_and_fitness



"""
    return a dictionary
        i_with_fitness = {i:fitness}
"""
def toDict(arr) :
    array = arr.copy()

    i_with_fitness = {}

    for i in range(len(array)):
        i_with_fitness[i] = array[i]

    return i_with_fitness



"""
    define a cumulative distribution function for FPS
    return a fake dictionary
        i_with_cp = [i,cdf]
"""
def calc_cdf(arr) :

    array = arr.copy()
    i_with_fitness = toDict(array)

    # rank dict by value descent #
    i_with_fitness = sorted(i_with_fitness.items(), key=lambda item: item[1], reverse=True)

    # sort array descent #
    array.sort(reverse=True)

    # an array stores partitions generated by FPS #
    partitions = []
    for item in array:
        partitions.append(item / sum(array))

    # cumulative probabilities #
    cps = [0]
    for i in range( len(partitions) ) :
        cps.append(   cps[i]+partitions[i]   )

    # the simulated dict #
    i_with_cp = []
    for i in range( len(cps)-1 ) :
        i_with_cp.append(   [ i_with_fitness[i][0], cps[i+1] ]   )

    return i_with_cp



#multi-pointer selection (MPS)
def MPS(fitness, mating_pool_size):

    selected_to_mate = []    # list of the indices of picked parents

    #student code begin

    cdf = calc_cdf(fitness)

    size = mating_pool_size
    pool = []

    pointer = random.uniform( 0, 1/size )
    current = 0
    i = 0

    while current < size :
        while pointer <= cdf[i][1] :
            pool.append( cdf[i][0] )
            pointer = pointer + 1/size
            current = current + 1
        i = i + 1

    selected_to_mate = pool

    #student code end

    return selected_to_mate




"""
    race the best one
    return best = [i,order]
        i: individual's id in fitness array,
        order: individual's index in shuffled i_and_fitness
"""
def raceBest(compete) :

    best_fit = 0
    best_id = 0
    order = 0
    for i in range( len(compete) ) :
        if compete[i][1] > best_fit :
            best_fit = compete[i][1]
            best_id = compete[i][0]
            order = i

    return [best_id,order]


#tournament selection without replacement
def tournament(fitness, mating_pool_size, tournament_size):

    selected_to_mate = []    # list of the indices of picked parents

    #student code begin

    # create an assoc array #
    i_and_fitness = toAssocArray(fitness)

    # shuffle to make random #
    random.shuffle(i_and_fitness)

    compete = []
    current = 0
    pool = []

    while current < mating_pool_size :
        for i in range(tournament_size) :
            compete.append(i_and_fitness[i])

        best = raceBest(compete)
        pool.append(best[0])
        del i_and_fitness[best[1]]
        compete = []
        current = current + 1
        random.shuffle(i_and_fitness)

    selected_to_mate = pool


    #student code end

    return selected_to_mate


#randomly uniformly pick parents
def random_uniform (population_size, mating_pool_size):

    selected_to_mate = []    # list of the indices of picked parents

    #student code begin

    pop_ids = []
    for i in range( population_size ) :
        pop_ids.append(i)
    random.shuffle(pop_ids)

    selected_to_mate = pop_ids[0:mating_pool_size]

    #student code end

    return selected_to_mate
